---
title: "function 키워드를 꼭 써야할까?"
description: "function 키워드와 ES6에 추가된 3가지 문법을 알아보자"
date: 2024-09-27 00:26:08
series: "Javascript"
image: ""
tags:
  - 자바스크립트
---

`this`에 대해 공부하던 중, 함수 선언식은 `this`가 동적으로 바인딩 된다는 것을 알게 된 후로 항상 의문이 들었다.

> 요즘은 예측 가능한 방향으로 기능이 작아지고 있는데 `function` 키워드는 왜이렇게 만들었지?

의문을 해결하기 위해 여러 자료들을 찾아보던 중, 어느정도 **[의문을 해소해준 영상](https://www.youtube.com/watch?v=LPEwb5plEoU)**이 있어서 이를 보고 간략하게 정리를 해보았다.

## function 키워드로 생성된 함수의 문제점

`function` 키워드로 만들어진 함수는 호출되는 시점에 `this`가 다르게 바인딩되는데 이 함수를 어떻게 쓰느냐에 따라서도 다르게 바인딩 되는 문제가 있다.

### 1. 전역에서 호출

```js
function myFunction() {
  console.log(this);
}

// 전역에서 호출
myFunction(); // window
```

이 때는 this가 `window` **객체**를 가리킨다.

### 2. 객체에서 메서드로 호출

```js
const myObject = {
  myFunction: function () {
    console.log(this);
  },
};

// 객체 내 메서드로 호출
myObject.myFunction(); // {myFunction: ...}
```

`this`가 **메서드를 포함한 객체**인`myObject`를 가리키고 있는 것을 볼 수 있다.

### 3. `new` 키워드로 인스턴스 생성

```js
// new 키워드로 인스턴스 생성 후 호출
const instance = new MyFunction(); // MyFunction {}
```

`this`는 생성자로 사용해 만들어진 **인스턴스**를 가리키게 된다.

이렇듯 함수 선언식으로 만들어진 함수는 선언 이후에 다양한 방법으로 호출하여 사용할 수 있다.
이 부분이 기존에는 하나의 기능으로 여러 역할을 수행할 수 있는 만능 기능이었지만 웹 어플리케이션의 규모가 커지고 체계화 되면서 여러 개발자가 협업하는 상황에서 함수를 만드는 개발자는 **의도대로 함수가 동작**하게 만들기 위해 **여러 조건을 설정해야 하는 불편함**이 생기게 된다.
또한, 이 모든 기능을 하나의 키워드로 처리하면서 기능이 무거워지는 문제도 뒤따르게 된다.

## ES6에 도입된 기능들

ES6에서는 `function` 키워드가 혼자 도맡고 있던 업무를 나누어 필요한 것만 사용할 수 있는 3가지 새로운 기능을 내놓았다.

**화살표 함수**, **메서드 축약 문법**, **클래스 문법**이다.

### 1. 화살표 함수

```js
const myObject = {
  name: "Object",
  regularFunction: function () {
    console.log(this.name); // this는 myObject를 가리킴
  },
  arrowFunction: () => {
    console.log(this.name); // 상위 스코프의 this를 가리킴 (전역 객체)
  },
};

myObject.regularFunction(); // "Object"
myObject.arrowFunction(); // undefined (전역 객체의 name이 없기 때문)
```

```js
function myFunction() {
  console.log(this.name);
}

const myObject = {
  name: "Object",
  myFunction: myFunction,
};

myFunction(); // undefined (전역 객체의 name이 없기 때문)
myObject.myFunction(); // "Object"
```

**화살표 함수**는 선언된 위치에서의 상위 스코프에 있는 `this`를 사용한다. 즉, 최초 선언된 순간 `this`가 정의되고 다른 값으로 바인딩 되지 않는다. 하지만 `function` 키워드는 다르다. **선언**이 아닌 **호출** 시점에 `this`를 바인딩한다.

개발자의 의도대로 바인딩을 하고 싶다면 기존에는 **apply**, **call**, **bind** 메서드를 사용해 직접 바인딩 했어야 했지만 화살표 함수는 이 메서드의 사용이 불가능하다. `this`가 가리키는 대상이 변하지 않아 **사용할 필요가 없기 때문**이다.

### 2. 메서드 축약 문법

```js
const obj = {
  myMethod1: function () {
    console.log(this);
  },
  myMethod2() {
    console.log(this);
  },
};

const instance1 = new obj.myMethod1(); // 가능
const instance2 = new obj.myMethod2(); // 오류 발생: obj.myMethod2 is not a constructor
```

각각의 메서드는 `this`가 동일하게 `obj`를 가리킨다.

하지만 일반 함수 선언식으로 호출 된 메서드는 생성자 함수로 사용하여 인스턴스를 만들 수 있는 반면, 메서드 축약 문법은 불가능하다. 메서드로써 활용하기 위한 기능만 포함하고 있기 때문이다.

인스턴스를 생성하기 위한 문법은 아래의 클래스 문법을 따르면 된다.

### 3. 클래스 문법

```js
function MyFunction() {
  console.log(this);
}

class MyClass {
  constructor() {
    console.log(this);
  }
}

const instance1 = new MyFunction(); // MyFunction 인스턴스
const instance2 = new MyClass(); // MyClass 인스턴스
MyFunction(); // 가능
MyClass(); // 오류 발생: Class constructor MyClass cannot be invoked without 'new'
```

`new` 키워드를 사용해 인스턴스를 생성하고, `this`가 생성된 인스턴스를 가리키는 것까지 동일하다.

하지만 결정적으로 `function`으로 선언된 함수는 인스턴스 생성 없이 함수 호출로 사용이 가능하지만 클래스는 new 키워드로 인스턴스를 생성해야 사용할 수 있다. 클래스는 다른 방법으로 사용될 수 있는 여지를 미연에 방지했다고 볼 수 있다.

## 결론

이처럼 기존에 많은 기능을 하나로 처리하고 있던 `function` 키워드는 새로운 문법의 도입으로 그 역할을 나누어 수행할 수 있게 되었다. `this`는 최대한 예측 가능하게 바인딩 되고, 각 기능의 사이즈는 작아져 더욱 가벼운 코드를 만들 수 있게 되었다. 그럼 `function` 키워드는 **더이상 사용하지 않아도 될까**?

> 아직은 아니다!

반환값을 여러개 할당 가능한 **제너레이터 함수** 등은 여전히 `function` 키워드를 사용하는 방법밖에 없다. 다만, 이를 제외하고는 `function` 키워드로 함수를 생성하고 이를 `this`와 함께 사용할 필요성이 많이 줄었다고 생각한다.

추가로 개인적인 생각이지만, 호이스팅이 가능했던 var, function 과 다르게 이후에 나온 **const**, **let**, **화살표 함수**, **클래스** 등은 변수는 호이스팅이 되지만 초기화는 호이스팅이 되지 않아 호이스팅이 '**사실상**' 불가능하다는 점으로 미루어 보아 **변수나 함수의 선언 전 호출 또한 점점 줄이려는걸까** 싶기도 하다.

참조: [[Javascript 미세팁] "function"은 아예 쓰지 마세요](https://www.youtube.com/watch?v=LPEwb5plEoU)
